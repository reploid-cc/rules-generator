---
description: Rule-based self-learning system with pattern detection, rule generation and quality validation
globs: .cursor/rules/**/*
alwaysApply: false
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# Î›.learning: Rule-Based Self-Learning System (821)

## ğŸ¯ Î›.core_framework: Learning System Framework

### Î›.structure: System Architecture
```
Î› = rule_based_self_learning
Î›.path = ".cursor/rules/"

Î›.naming_convention = {
    "0â– â– ": "Core standards",
    "1â– â– ": "Tool configurations", 
    "3â– â– ": "Testing rules",
    "1â– â– â– ": "Language-specific",
    "2â– â– â– ": "Framework-specific", 
    "8â– â– ": "Workflows",
    "9â– â– ": "Templates",
    "_name.mdc": "Private rules"
}

// Note: Category masks, not fixed literals. Use incremental IDs.
```

### Î›.pattern_alignment: Quality Enforcement
```
Î›.pattern_alignment = (
    align_code_with_best_practices()
    â¨ suggest_patterns_only_when_justified()
    â¨ enforce_SRP_avoid_premature_abstraction()
)

Î›.best_practices = {
    SRP: "Single Responsibility Principle - One clear purpose per function/class",
    simplicity_guard: "Challenge overengineering, delay abstraction",
    pattern_justification: "Only suggest patterns when clearly beneficial",
    context_awareness: "Apply rules based on project structure and scope"
}
```

## ğŸ¯ Î›.implementation: Learning System Implementation

### Î›.autonomy: Intelligent Rule Generation
```
Î›.autonomy = (
    auto_detect_rule_worthy_recurrences()
    â¨ generate__DRAFT_mdc_in_context()
)

Î›.rule_discovery_process = {
    pattern_detection: "Identify recurring issues or solutions",
    context_analysis: "Evaluate if pattern is generalizable",
    rule_drafting: "Generate _DRAFT.mdc for review",
    validation: "Test rule effectiveness across scenarios",
    integration: "Promote to official rule with proper naming"
}
```

### Î›.extract: Experience Learning
```
Î›.extract = (
    triggered_on_sprint_review()
    â¨ analyze_what_worked_vs_what_didnt()
    â¨ identify_reusable_patterns()
    â¨ suggest_rule_improvements()
)

Î›.learning_triggers = {
    recurring_issues: "Same problem appears >2 times",
    successful_patterns: "Proven effective solutions",
    anti_patterns: "Documented problematic approaches",
    tool_configurations: "Effective setup procedures"
}

Î.recurrence_threshold = 2
Î.pattern_suggestion = (
    if_recurring_fixable_issues_detected()
    â¨ auto_generate_rule_draft_in_Î›.path()
    â¨ suggest_reusable_strategy()
)
```

## ğŸ¯ Î›.integration: System Integration

### Î›.cross_references: Related Rules
```
Î›.related_rules = {
    "0xx-core": ["core/001-core-standards.mdc"],
    "1xx-protocols": ["protocols/111-memory-initialization.mdc"],
    "8xx-workflows": ["workflow/801-task-system.mdc"],
    "8xx-engines": ["engines/841-phi-hypothesis.mdc", "engines/851-xi-diagnostics.mdc"],
    "9xx-templates": ["templates/901-template-standards.mdc"],
    "integration": ["tasks-integration.mdc", "memory-integration.mdc"]
}
```

### Î›.system_hooks: Integration Points
```
Î©.scope = (
    infer_project_structure_from_files_and_imports()
    â¨ detect_implicit_dependencies()
    â¨ observe_ripple_effects()
    â¨ activate_Î›.rules_in_context()
    â¨ silent_observer_mode_to_respect_IDE_logic()
)

Î›.cross_system_integration = {
    Î¨.traces: "Rules invoked logged in cognitive traces",
    T.tasks: "Rule compliance checked in task validation",
    Î.diagnostics: "Rule effectiveness monitored",
    M.memory: "Rule patterns stored for future reference"
}

Dâº.rule_conflict = (
    identify_conflicting_rules()
    â¨ resolve_by_priority_context_or_specificity()
    â¨ log_resolution_in_Î¨.dialog()
)
```

## ğŸ¯ Î›.quality: Quality Standards

### Î›.validation_protocol: Quality Assurance
```
Î›.rule_effectiveness_criteria = {
    actionable: "Clear, executable instructions",
    contextual: "Applies to appropriate scenarios",
    testable: "Can verify rule effectiveness",
    maintainable: "Easy to update as context evolves"
}

Î›.rule_template = `
---
description: Brief rule purpose
globs: [optional file patterns]
alwaysApply: [true|false]
---
# Rule Title (XXX)

## ğŸ¯ Purpose & Context
Clear explanation of when and why this rule applies

## ğŸ¯ Implementation Guidelines
Specific, actionable instructions

## ğŸ¯ Quality Validation
How to verify rule effectiveness

## ğŸ¯ Integration Points
How this rule interacts with other systems

---
*Rule effectiveness tracking note*
`
```

### Î›.anti_patterns: Error Prevention
```
Î›.anti_patterns = {
    premature_rule_creation: âš ï¸ MAJOR_VIOLATION,
    overly_specific_rules: âš¡ VIOLATION,
    conflicting_rules: ğŸ”´ CRITICAL_VIOLATION,
    inadequate_rule_testing: âš ï¸ MAJOR_VIOLATION,
    excessive_rule_complexity: âš¡ VIOLATION,
    insufficient_context_awareness: âš¡ VIOLATION,
    missing_integration_points: âš¡ VIOLATION
}

Î›.rule_validation = (
    test_rule_in_multiple_contexts()
    â¨ verify_clear_actionable_instructions()
    â¨ confirm_integration_with_existing_systems()
    â¨ monitor_effectiveness_over_time()
    â¨ update_based_on_usage_feedback()
)
```

### Î›.application_workflow: Rule Application Process
```
Î›.application_workflow = (
    detect_relevant_context_from_user_request()
    â¨ identify_applicable_rules_based_on_globs_and_content()
    â¨ fetch_rules_before_implementation()
    â¨ apply_rules_in_priority_order()
    â¨ validate_outcomes_against_rule_criteria()
)
```

---
*Î›.learning: comprehensive_rule_based_self_learning_system_with_intelligent_pattern_detection_context_aware_rule_generation_cross_system_integration_and_continuous_improvement*


