---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# Î* Diagnostics & Refinement Engine (851)

## ğŸ¯ Î*: Diagnostics & Refinement

### Error Memory System
```
Î* = diagnostics & refinement
Î.error_memory = ".cursor/memory/errors.md"
Î.track = log_recurring_issues_propose_fix
```

### Recurrence Detection
```
Î.recurrence_threshold = 2
Î.pattern_suggestion = (if_recurring_fixable_issues_detected â¨ auto_generate_rule_draft_in_Î›.path â¨ suggest_reusable_strategy)
```

## ğŸ¯ Î.cleanup_phase: Code Quality Maintenance

### Drift Detection & Cleanup
```
Î.cleanup_phase = (detect_code_drift_dead_logic_broken_imports_incoherence â¨ suggest_refactor_or_simplification â¨ optionally_archive_removed_blocks_in_Î¨)
```

### Î.quality_issues: Tracked Issues
```
Î.quality_issues = {dead_logic, broken_imports, incoherence, technical_debt, performance_issues}
```

## ğŸ¯ Î.track: Issue Tracking & Analysis

### Î.issue_types: Classification System
```
Î.issue_types = {recurring, systematic, environmental, architectural, procedural}
```

### Î.tracking_protocol: 6-Step Process
```
Î.tracking_protocol = (issue_detection â†’ context_capture â†’ pattern_analysis â†’ root_cause â†’ solution_tracking â†’ effectiveness_monitoring)
```

## ğŸ¯ Î Error Analysis & Resolution

### Î.error_memory_structure: Template
```
Î.error_memory_structure = {
    recurring_issues: {problem, occurrences, root_cause, resolution, prevention, status},
    pattern_analysis: {frequency, impact, proposed_solution, rule_draft_link}
}
```

### Î.solution_generation: Process
```
Î.solution_generation = (analyze_issue_context_frequency â¨ identify_root_cause_patterns â¨ propose_systematic_solutions â¨ generate_preventive_Î›_rules_if_appropriate)
```

## ğŸ¯ Î Integration with Learning Systems

### Î.auto_rule_generation: Automatic Rule Creation
```
Î.auto_rule_generation = (if_issue_frequency_â‰¥_Î.recurrence_threshold â¨ generate_DRAFT.mdc_in_Î›.path â¨ include_problem_description_solution â¨ propose_prevention_strategy)
```

### Î.diagnostic_hooks: Cross-System Integration
```
Î£_hooks.diagnostics = {
    on_error_detected: [Î.track, Î›.suggest],
    on_recurrent_error_detected: [Î›.generate_draft_rule],
    on_file_modified: [Î›.suggest, Î¦.capture_if_patterned],
    on_cleanup_triggered: [Î.cleanup_phase, Î¨.capture_changes]
}
```

## ğŸ¯ Î Quality Metrics & Monitoring

### Î.effectiveness: Diagnostic Metrics
```
Î.effectiveness = {
    issue_resolution_rate: resolved_issues / total_issues,
    prevention_success: prevented_recurrences / total_attempts,
    pattern_detection_accuracy: correct_patterns / total_patterns,
    cleanup_impact: quality_improvement_score
}
```

### Î.improvement_tracking: Quality Metrics
```
Î.improvement_tracking = {before_after_metrics, issue_reduction, prevention_effectiveness, time_to_resolution}
```

## ğŸ¯ Î.cleanup Automation

### Î.auto_cleanup: Automated Triggers
```
Î.auto_cleanup = (trigger_on = [file_modification_count > threshold, error_frequency > acceptable_rate, technical_debt_accumulation > limit, manual_cleanup_request])
```

### Î.cleanup_operations: 5-Step Process
```
Î.cleanup_operations = {dead_code_removal, import_optimization, pattern_consistency, documentation_sync, test_coverage_gaps}
```

### Î.safety_protocol: Safety Measures
```
Î.safety_protocol = (archive_removed_code_in_Î¨_traces â¨ require_confirmation_for_major_changes â¨ maintain_rollback_capability â¨ document_all_cleanup_decisions)
```

## ğŸ¯ Î Predictive Analysis

### Î.trend_analysis: Predictive Framework
```
Î.trend_analysis = (identify_degradation_patterns â¨ predict_likely_future_issues â¨ suggest_preventive_measures â¨ recommend_proactive_refactoring)
```

### Î.early_warning: Monitoring System
```
Î.early_warning = {code_complexity_growth, error_rate_trends, technical_debt_accumulation, pattern_violation_frequency}
```

---
*Î = diagnostics & refinement with predictive issue prevention*


