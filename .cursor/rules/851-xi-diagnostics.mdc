---
description: Diagnostics and refinement engine with issue recognition, code quality maintenance and trend analysis
globs: 
alwaysApply: false
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# Î.diagnostics: Diagnostics & Refinement Engine (851)

## ğŸ¯ Î.core_framework: Diagnostics Framework

### Î.structure: System Architecture
```
Î = diagnostics_and_refinement_engine
Î.error_memory = ".cursor/memory/errors.md"
Î.track = log_recurring_issues_propose_fix
Î.recurrence_threshold = 2
```

### Î.pattern_detection: Issue Recognition
```
Î.pattern_suggestion = (
    if_recurring_fixable_issues_detected()
    â¨ auto_generate_rule_draft_in_Î›.path()
    â¨ suggest_reusable_strategy()
)

Î.issue_types = {
    recurring: "same_problem_multiple_times",
    systematic: "pattern_of_related_issues",
    environmental: "setup_or_configuration_problems",
    architectural: "fundamental_design_issues",
    procedural: "process_or_workflow_problems"
}
```

## ğŸ¯ Î.implementation: Diagnostics Implementation

### Î.cleanup_phase: Code Quality Maintenance
```
Î.cleanup_phase = (
    detect_code_drift_dead_logic_broken_imports_incoherence()
    â¨ suggest_refactor_or_simplification()
    â¨ optionally_archive_removed_blocks_in_Î¨.traces()
)

Î.code_quality_issues = {
    dead_logic: "Unreachable or unused code",
    broken_imports: "Missing or incorrect dependencies",
    incoherence: "Inconsistent patterns or naming",
    technical_debt: "Accumulated shortcuts or workarounds",
    performance_issues: "Inefficient implementations"
}
```

### Î.track: Issue Tracking Protocol
```
Î.tracking_protocol = {
    issue_detection: "Identify problem occurrence",
    context_capture: "Record surrounding circumstances",
    pattern_analysis: "Check for recurring patterns",
    root_cause: "Determine underlying cause",
    solution_tracking: "Document resolution approach",
    effectiveness: "Monitor solution success"
}

Î.error_memory_structure = `
# errors.md

## Recurring Issues
### [Issue Category]
- **Problem**: Description of the issue
- **Occurrences**: Timestamps and contexts
- **Root Cause**: Underlying reason
- **Resolution**: Applied solution
- **Prevention**: How to avoid in future
- **Status**: [Active|Resolved|Monitoring]

## Pattern Analysis
### [Pattern Name]
- **Frequency**: How often it occurs
- **Impact**: Severity and scope
- **Proposed Solution**: Systematic fix
- **Rule Draft**: Link to generated Î› rule
`
```

## ğŸ¯ Î.integration: System Integration

### Î.rule_generation: Learning Integration
```
Î.solution_generation = (
    analyze_issue_context_and_frequency()
    â¨ identify_root_cause_patterns()
    â¨ propose_systematic_solutions()
    â¨ generate_preventive_Î›.rules_if_appropriate()
)

Î.auto_rule_generation = (
    if_issue_frequency_greater_than_or_equal_to_Î.recurrence_threshold()
    â¨ generate__DRAFT_mdc_in_Î›.path()
    â¨ include_problem_description_and_solution()
    â¨ propose_prevention_strategy()
)
```

### Î.cross_references: Related Rules
```
Î.related_rules = {
    "0xx-core": ["core/001-core-standards.mdc"],
    "1xx-protocols": ["protocols/111-memory-initialization.mdc"],
    "8xx-workflows": ["workflow/801-task-system.mdc"],
    "8xx-engines": ["engines/821-lambda-learning.mdc", "engines/841-phi-hypothesis.mdc"],
    "integration": ["memory-integration.mdc"]
}
```

### Î.system_hooks: Integration Points
```
Î£.hooks.diagnostics = {
    on_error_detected: [Î.track, Î›.suggest],
    on_recurrent_error_detected: [Î›.generate_draft_rule],
    on_file_modified: [Î›.suggest, Î¦.capture_if_patterned],
    on_cleanup_triggered: [Î.cleanup_phase, Î¨.capture_changes]
}
```

## ğŸ¯ Î.quality: Quality Standards

### Î.validation_protocol: Quality Assurance
```
Î.effectiveness = {
    issue_resolution_rate: "resolved_issues / total_issues",
    prevention_success: "prevented_recurrences / total_attempts",
    pattern_detection_accuracy: "correct_patterns / total_patterns",
    cleanup_impact: "quality_improvement_score"
}

Î.quality_improvement_tracking = {
    before_after_metrics: "Code quality scores pre/post cleanup",
    issue_reduction: "Decrease in recurring problems",
    prevention_effectiveness: "Success of preventive measures",
    time_to_resolution: "Speed of issue identification and fixing"
}
```

### Î.automation: Cleanup Automation
```
Î.auto_cleanup = (
    trigger_on = [
        file_modification_count_greater_than_threshold(),
        error_frequency_greater_than_acceptable_rate(),
        technical_debt_accumulation_greater_than_limit(),
        manual_cleanup_request()
    ]
)

Î.cleanup_operations = {
    dead_code_removal: "Identify and suggest removal of unused code",
    import_optimization: "Fix broken or redundant imports",
    pattern_consistency: "Align with established patterns",
    documentation_sync: "Update docs to match implementation",
    test_coverage: "Identify gaps in test coverage"
}

Î.safety_protocol = (
    archive_removed_code_in_Î¨.traces()
    â¨ require_confirmation_for_major_changes()
    â¨ maintain_rollback_capability()
    â¨ document_all_cleanup_decisions()
)
```

### Î.anti_patterns: Error Prevention
```
Î.anti_patterns = {
    ignoring_recurring_issues: ğŸ”´ CRITICAL_VIOLATION,
    failing_to_document_errors: âš ï¸ MAJOR_VIOLATION,
    bypassing_cleanup_phase: âš ï¸ MAJOR_VIOLATION,
    skipping_root_cause_analysis: âš¡ VIOLATION,
    premature_rule_generation: âš¡ VIOLATION,
    inconsistent_issue_tracking: âš¡ VIOLATION,
    neglecting_trend_analysis: âš¡ VIOLATION
}

Î.trend_analysis = (
    identify_degradation_patterns()
    â¨ predict_likely_future_issues()
    â¨ suggest_preventive_measures()
    â¨ recommend_proactive_refactoring()
)

Î.early_warning_system = {
    code_complexity_growth: "Monitor increasing complexity",
    error_rate_trends: "Track error frequency changes",
    technical_debt_accumulation: "Measure debt growth rate",
    pattern_violation_frequency: "Monitor rule compliance"
}
```

---
*Î.diagnostics: comprehensive_diagnostics_and_refinement_engine_with_error_tracking_code_quality_maintenance_pattern_detection_and_automated_cleanup_capabilities*


