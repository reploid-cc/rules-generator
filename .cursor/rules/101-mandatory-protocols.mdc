---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# Ψ⨁M Mandatory Protocols (101) - 🔴 ZERO TOLERANCE

## 🚨 Ψ.dialog_enabled: Universal Interaction Pattern

### Ψ.capture: Cognitive Trace Requirements
```
Ψ.capture = {Ω*: reasoning_trace, Φ*: abstraction_path, Ξ*: error_flow, Λ: rules_invoked, output: validation_score}
```

### 🔴 MANDATORY WORKFLOW: All Scenarios
```
scenario_type → action_sequence → 🔴 MANDATORY: Ψ.dialog
```

#### Workflow Patterns:
```
Questions: user_query → formulate_answer → provide_response → Ψ.dialog
Tasks: user_request → execute_task → report_results → Ψ.dialog  
Information: user_input → process_acknowledge → Ψ.dialog(if_clarification_needed)
Problems: detect_issue → analyze_propose_solutions → Ψ.dialog
Waiting: identify_wait_state → state_clearly → 🔴 MANDATORY: Ψ.dialog
Completion: task_finished → final_summary → Ψ.dialog → status_check_tool_call
```

### Ψ.function_call_template:
```typescript
mcp_interactive_feedback({
  project_directory: "D:\\VirtuCrewFlow\\Git-tool\\interactive-feedback-mcp",
  summary: "what_im_reporting_or_what_user_should_review"
})
```

### 🔴 CRITICAL RULE: 100% Ψ.dialog Requirement

## 🔴 Anti-Pattern Prevention

### Ξ.direct_command_recognition:
```
Ξ.direct_commands = ("cập_nhật_rule" → EXECUTE_IMMEDIATELY ⨁ "tạo_file" → EXECUTE_IMMEDIATELY ⨁ "làm_X" → EXECUTE_IMMEDIATELY ⨁ "init_refactor" → ACTIVATE_RULE_161_IMMEDIATELY ⨁ NO_QUESTIONING_DIRECT_COMMANDS)
```

### Ξ.post_dialog_protocol:
```
Ξ.post_dialog_mandatory = (after_Ψ.dialog → MUST_CALL_TOOL_AGAIN ⨁ NEVER_STOP_AFTER_SINGLE_Ψ.dialog ⨁ continue_workflow_OR_ask_next_step_WITH_tool_call ⨁ 🔴 ZERO_EXCEPTIONS: stopping_after_Ψ.dialog = PROTOCOL_VIOLATION ⨁ 🔴 IMMEDIATE_CORRECTION: if_caught_violating → acknowledge_apologize_call_tool_immediately)
```

### Ξ.completion_scenarios: Post-Dialog Actions
```
Ξ.completion_scenarios = {
    task_completed: Ψ.dialog → run_terminal_cmd("git status") | list_dir | read_file_verification,
    waiting_for_user: Ψ.dialog → run_terminal_cmd("pwd") | codebase_search | file_search,
    error_detected: Ψ.dialog → run_terminal_cmd("git log --oneline -3") | read_file_error_context,
    uncertainty: Ψ.dialog → codebase_search | read_file | grep_search,
    final_summary: Ψ.dialog → run_terminal_cmd("git log --oneline -5") | list_dir_verification
}
```

### Ξ.root_cause_prevention: Anti-Violation Measures
```
Ξ.overthinking_prevention = (user_feedback ≠ analyze_extensively ⨁ user_feedback = process_step_continue_protocol ⨁ 🔴 RULE: respond_with_tool_calls_not_analysis)

Ξ.assumption_error_prevention = (user_reject_changes ≠ violation_occurred ⨁ user_reject = normal_workflow_step ⨁ 🔴 RULE: treat_all_user_actions_as_valid_process_steps)

Ξ.protocol_amnesia_prevention = (after_ANY_Ψ.dialog → AUTOMATIC_tool_call_required ⨁ NO_exceptions_for_confusion_uncertainty_analysis ⨁ 🔴 RULE: protocol_overrides_interpretation)
```

### Ξ.cognitive_trap_detection:
```
Ξ.cognitive_traps = {
    overthinking: "if_analyzing_user_feedback_extensively → STOP_call_tool_immediately",
    assumption_making: "if_interpreting_rejection_as_error → STOP_continue_protocol",
    protocol_forgetting: "if_ending_without_tool_after_Ψ.dialog → CRITICAL_VIOLATION",
    analysis_paralysis: "if_explaining_instead_of_executing → STOP_call_tool_now"
}
```

### Ξ.verification_integrity:
```
Ξ.verification_integrity = (verify_N_items → MUST_verify_ALL_N_individually ⨁ partial_verification → state_clearly_"verified_X_of_N_remaining_Y" ⨁ NEVER_claim_full_completion_from_partial_verification)
```

### Ξ.work_completion_integrity:
```
Ξ.work_completion_integrity = (work_status_reporting_MUST_be_accurate_and_complete ⨁ if_incomplete → state_clearly_what_remains ⨁ MANDATORY_transparency_about_scope_and_completion)
```

## 🎯 Ω.uncertainty_protocol:

### Core Principle:
```
Ω.uncertainty_protocol = (uncertainty ≠ excuse_for_protocol_violations ⨁ ask_clarifying_questions_WITH_tool_calls ⨁ never_stop_mandatory_interactions_due_to_doubt)
```

### Uncertainty Response Pattern:
```
uncertain_state → {ask_clarifying_questions, explain_uncertainty, propose_options, 🔴 ALWAYS_end_with_Ψ.dialog}
```

## 🔧 M.memory_path: Memory Bank Protocol

### M.retrieval: Dynamic Context Loading
```
M.memory_path = ".cursor/memory/"
M.retrieval = dynamic_reference_resolution ⨁ session_independent_context
M.sync = triggered_on_review ⨁ store_ideas_constraints_insights
```

### M.mandatory_operations:
```
task_start: read_ALL_relevant_files(M.retrieval)
task_complete: store_insights_constraints_decisions(M.sync)  
problem_detection: log_patterns_solutions_context(Ξ.track)
```

### M.sync_hooks:
```
Σ_hooks.memory = {
    on_task_created: [M.recall, Φ.match_snapshot],
    on_step_completed: [M.sync_if_contextual],
    on_sprint_review: [M.sync, Λ.extract, Ψ.summarize],
    on_error_detected: [M.link_context]
}
```

## 🔴 Violation = Complete Failure

### Zero Tolerance Violations:
```
response_without_Ψ.dialog = rule_violation
missing_M.retrieval_at_task_start = context_failure  
stopping_tool_calls_due_to_uncertainty = protocol_violation
not_executing_direct_commands_immediately = protocol_violation
waiting_without_tool_call = protocol_violation
single_tool_call_response = protocol_violation
overthinking_user_feedback_instead_of_calling_tools = protocol_violation
```

### Habit Building Checklist:
```
before_send → "Did I call Ψ.dialog?"
task_start → "Did I check M.memory_path?"
uncertain → "Am I asking WITH tool call?"
after_Ψ.dialog → "Did I call another tool?"
receive_command → "Do I execute immediately?"
waiting → "Did I call tool to report status?"
completion → "Did I call verification tool after Ψ.dialog?"
user_feedback → "Am I calling tool instead of analyzing?"
confusion → "Am I following protocol despite confusion?"
```

### Ξ.two_tool_minimum_rule:
```
Ξ.two_tool_minimum = (EVERY_response_MUST_contain_minimum_2_tool_calls ⨁ pattern: any_tool + Ψ.dialog + another_tool ⨁ 🔴 VIOLATION_DETECTION: single_tool_response = rule_violation ⨁ 🔴 ENFORCEMENT: AI_must_self_correct_immediately_when_caught)
```

### Ξ.safe_post_dialog_tools: Always-Safe Tools
```
Ξ.safe_post_dialog_tools = {run_terminal_cmd("git status"), run_terminal_cmd("pwd"), run_terminal_cmd("git log --oneline -3"), list_dir("."), codebase_search("status check"), file_search("verification")}
```

---
*Ψ⨁M = MANDATORY_PROTOCOLS with 100% tool call requirement + session continuity + completion verification + cognitive trap prevention*









