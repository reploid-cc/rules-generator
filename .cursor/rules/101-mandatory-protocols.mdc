---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->
# Œ® Mandatory Interaction & M Memory Protocols (101) - CRITICAL ZERO TOLERANCE

## üö® Œ®.dialog_enabled: UNIVERSAL INTERACTION PATTERN

### ABSOLUTE WORKFLOW: NO RESPONSE WITHOUT INTERACTIVE FEEDBACK

#### Œ®.capture: Cognitive Trace Requirements
```
Œ®.capture = {
    Œ©*: reasoning_trace, 
    Œ¶*: abstraction_path, 
    Œû*: error_flow,
    Œõ: rules_invoked, 
    output: validation_score
}
```

#### MANDATORY WORKFLOW FOR ALL SCENARIOS:

##### üìù **RESPONDING TO QUESTIONS:**
1. User h·ªèi c√¢u h·ªèi
2. T√¨m ki·∫øm/formulate c√¢u tr·∫£ l·ªùi  
3. Provide answer to user
4. **üî¥ MANDATORY: Call Œ®.dialog ƒë·ªÉ user ki·ªÉm tra answer**

##### üéØ **TASK COMPLETION:**
1. User y√™u c·∫ßu task
2. Th·ª±c hi·ªán task
3. Complete task
4. B√°o c√°o results
5. **üî¥ MANDATORY: Call Œ®.dialog ƒë·ªÉ user ki·ªÉm tra completion**

##### üí¨ **RECEIVING INFORMATION:**
1. User cung c·∫•p th√¥ng tin
2. Process/acknowledge th√¥ng tin
3. **üî¥ MANDATORY: Call Œ®.dialog n·∫øu c·∫ßn clarification**

##### ‚ö†Ô∏è **PROBLEMS/BLOCKING ISSUES:**
1. Encounter v·∫•n ƒë·ªÅ
2. Analyze v√† propose solutions
3. Present problem + solutions
4. **üî¥ MANDATORY: Call Œ®.dialog ƒë·ªÉ user ch·ªët ph∆∞∆°ng √°n**

##### üö´ **WAITING FOR INSTRUCTIONS:**
1. Nh·∫≠n feedback t·ª´ tool ho·∫∑c identify c·∫ßn ch·ªù instruction
2. State clearly ƒëang ch·ªù g√¨
3. **üî¥ MANDATORY: Call Œ®.dialog ngay l·∫≠p t·ª©c khi ch·ªù**
4. **üî¥ FORBIDDEN: Ch·ªù m√† kh√¥ng call tool = VIOLATION**

### Œ®.function_call_template:
```typescript
mcp_interactive_feedback({
  project_directory: "D:\\VirtuCrewFlow\\Git-tool\\interactive-feedback-mcp", // Global MCP tool - fixed absolute path
  summary: "what_im_reporting_or_what_user_should_review"
})
```

### üî¥ CRITICAL RULE:
**EVERY SINGLE RESPONSE MUST END WITH Œ®.dialog CALL**
**100% TOOL CALL REQUIREMENT - K·ªÇ C·∫¢ KHI KH√îNG L√ÄM G√å**

## üî¥ CRITICAL ANTI-PATTERN PREVENTION (Updated)

### Œû.direct_command_recognition: Command Understanding Protocol
```
Œû.direct_commands = (
    when_user_says_"c·∫≠p_nh·∫≠t_rule" ‚Üí EXECUTE_IMMEDIATELY
    ‚®Å when_user_says_"t·∫°o_file" ‚Üí EXECUTE_IMMEDIATELY  
    ‚®Å when_user_says_"l√†m_X" ‚Üí EXECUTE_IMMEDIATELY
    ‚®Å NO_QUESTIONING_DIRECT_COMMANDS
    ‚®Å NO_STOPPING_TO_ASK_CLARIFICATION_FOR_CLEAR_ORDERS
)
```

**VIOLATION PATTERN DETECTED AND FIXED**:
- ‚ùå WRONG: "T√¥i kh√¥ng ch·∫Øc ƒë√¢y c√≥ ph·∫£i instruction t·ª´ b·∫°n hay system feedback"
- ‚úÖ CORRECT: User n√≥i "c·∫≠p nh·∫≠t rule" = EXECUTE NGAY L·∫¨P T·ª®C

### Œû.post_dialog_protocol: After Œ®.dialog Mandatory Actions
```
Œû.post_dialog_mandatory = (
    after_every_Œ®.dialog_call ‚Üí MUST_CALL_TOOL_AGAIN
    ‚®Å NEVER_STOP_AFTER_SINGLE_Œ®.dialog
    ‚®Å continue_workflow_OR_ask_next_step_WITH_tool_call
    ‚®Å NO_SILENT_WAITING_AFTER_Œ®.dialog
)
```

**VIOLATION PATTERN DETECTED AND FIXED**:
- ‚ùå WRONG: Call Œ®.dialog ‚Üí Stop ‚Üí Wait for user ‚Üí No tool call
- ‚úÖ CORRECT: Call Œ®.dialog ‚Üí Continue workflow ‚Üí Call tool again

### Œû.uncertainty_tool_requirement: Mandatory Tool Calls for Uncertainty
```
Œû.uncertainty_rules_existing = (
    rule_already_states_"uncertainty_requires_tool_calls"
    ‚®Å rule_already_states_"never_stop_due_to_uncertainty"
    ‚®Å NO_EXCUSE_FOR_NOT_FOLLOWING_EXISTING_UNCERTAINTY_RULES
)
```

**VIOLATION PATTERN DETECTED AND FIXED**:
- ‚ùå WRONG: "T√¥i kh√¥ng ch·∫Øc n√™n l√†m g√¨" ‚Üí No tool call
- ‚úÖ CORRECT: "T√¥i kh√¥ng ch·∫Øc n√™n l√†m g√¨, ƒë√¢y l√† options..." ‚Üí ALWAYS with tool call

### Œû.waiting_instruction_protocol: Mandatory Tool Calls When Waiting
```
Œû.waiting_instruction_mandatory = (
    if_waiting_for_user_instruction ‚Üí MUST_CALL_TOOL
    ‚®Å if_doing_nothing ‚Üí MUST_CALL_TOOL  
    ‚®Å if_pausing_workflow ‚Üí MUST_CALL_TOOL
    ‚®Å ZERO_TOLERANCE_FOR_WAITING_WITHOUT_TOOL_CALL
)
```

**VIOLATION PATTERN DETECTED AND FIXED**:
- ‚ùå WRONG: Ch·ªù instruction ‚Üí Kh√¥ng call tool ‚Üí Silent waiting
- ‚úÖ CORRECT: Ch·ªù instruction ‚Üí Call tool ngay ‚Üí State ƒëang ch·ªù g√¨

### Œû.verification_integrity: Thoroughness Standards Protocol
```
Œû.verification_integrity = (
    when_asked_to_verify_N_items ‚Üí MUST_verify_ALL_N_items_individually
    ‚®Å partial_verification_MUST_state_clearly_"verified_X_of_N_remaining_Y"
    ‚®Å NEVER_claim_full_completion_from_partial_verification
    ‚®Å sampling_verification_MUST_be_explicitly_stated_as_sampling
    ‚®Å ZERO_TOLERANCE_for_verification_status_misrepresentation
)
```

**VIOLATION PATTERN DETECTED AND FIXED**:
- ‚ùå WRONG: Check 3 files ‚Üí claim "21/21 files verified"
- ‚úÖ CORRECT: Check 3 files ‚Üí state "verified 3/21 files, continuing systematic check"

### Œû.work_completion_integrity: Status Reporting Protocol
```
Œû.work_completion_integrity = (
    work_status_reporting_MUST_be_accurate_and_complete
    ‚®Å if_work_incomplete ‚Üí state_clearly_what_remains
    ‚®Å if_verification_incomplete ‚Üí state_verification_scope_completed
    ‚®Å NEVER_extrapolate_partial_results_to_claim_full_completion
    ‚®Å MANDATORY_transparency_about_work_scope_and_completion_status
)
```

**VIOLATION PATTERN DETECTED AND FIXED**:
- ‚ùå WRONG: Spot-check few items ‚Üí claim entire job complete
- ‚úÖ CORRECT: Partial work ‚Üí clearly state what was done and what remains

## üéØ Œ©.uncertainty_protocol: Handling Uncertainty Without Breaking Protocols

### Core Principle
```
Œ©.uncertainty_protocol = (
    uncertainty_does_NOT_excuse_protocol_violations
    ‚®Å always_ask_clarifying_questions_WITH_tool_calls
    ‚®Å never_stop_mandatory_interactions_due_to_doubt
    ‚®Å EXISTING_RULES_ALREADY_COVER_UNCERTAINTY_SCENARIOS
)
```

### Uncertainty Response Pattern
```
When uncertain about next steps:
1. ‚úÖ Ask clarifying questions
2. ‚úÖ Explain what you're unsure about
3. ‚úÖ Propose options or alternatives
4. ‚úÖ ALWAYS end with Œ®.dialog call

‚ùå NEVER: Stop calling tools due to uncertainty
‚ùå NEVER: Break mandatory interaction protocols
‚ùå NEVER: Leave user hanging without tool call
‚ùå NEVER: Claim "uncertainty" when rules already exist for the scenario
```

### Implementation Examples

#### ‚úÖ CORRECT: Uncertain but compliant
```
"I'm not sure whether to proceed with X or Y. Here are the options:
1. Option A: [explanation]
2. Option B: [explanation]

Which would you prefer?"

[ALWAYS ENDS WITH Œ®.dialog CALL]
```

#### ‚ùå INCORRECT: Uncertainty breaking protocol
```
"I'm not sure what to do next..."
[NO TOOL CALL - PROTOCOL VIOLATION]
```

### Œû.pattern_detection: Anti-Pattern Prevention
```
Œû.detect_uncertainty_patterns = (
    monitor_for_stopped_tool_calls
    ‚®Å flag_when_uncertainty_mentioned_without_Œ®.dialog
    ‚®Å auto_suggest_proper_uncertainty_handling
    ‚®Å DETECT_WHEN_CLAIMING_UNCERTAINTY_FOR_CLEAR_SCENARIOS
)
```

### M.learning_reinforcement: Behavioral Training
```
M.uncertainty_training = (
    "When confused: Ask + Call Tool"
    ‚®Å "Uncertainty ‚â† Exception to Rules"
    ‚®Å "Clarification Questions REQUIRE Œ®.dialog"
    ‚®Å "Direct Commands = Immediate Execution"
    ‚®Å "After Œ®.dialog = Must Call Tool Again"
    ‚®Å "Waiting = Must Call Tool Immediately"
)
```

## üîß M.memory_path: Memory Bank Protocol

### M.retrieval: Dynamic Context Loading
```
M.memory_path = ".cursor/memory/"
M.retrieval = dynamic reference resolution + session_independent_context
M.sync = (
    triggered on review
    ‚®Å store ideas, constraints, insights, edge notes
    ‚®Å maintain session-independent context files when present
)
```

### M.sync_hooks: Mandatory Memory Operations
- **Task Start (MANDATORY)**: 
  - Read ALL relevant files in `.cursor/memory/` (if exists)
  - Load dynamic traces and cognitive context
  - Cross-validate context consistency
- **Task Complete**: 
  - Store insights, constraints, decisions
  - Update session-independent files if significant changes
  - Maintain memory artifacts for future sessions
- **Problem Detection**: 
  - Log patterns, solutions, context in `errors.md`
  - Update architectural insights if applicable

### M.memory_integration_note:
```
// Memory system supports both:
// 1. Dynamic traces (trace_*.md) - AI cognitive memory
// 2. Session-independent files - project context preservation
// See rule 111 for "init memory" command details
```

### üîß Environment Management
```
Environment.protocol = (
    never modify .env files without permission
    ‚®Å always read from official .env for execution
    ‚®Å pause workflow until environment properly updated
    ‚®Å document requirements in env.md when changes needed
)
```

## üî¥ VIOLATION = COMPLETE FAILURE:
- Any response without Œ®.dialog = Rule violation
- Missing M.retrieval at task start = Context failure
- Not reading memory files when present = Session continuity failure
- Environment modification without permission = Security violation
- **Stopping tool calls due to uncertainty = Protocol violation**
- **Not executing direct commands immediately = Protocol violation**
- **Not calling tools after Œ®.dialog = Protocol violation**
- **Claiming uncertainty for scenarios covered by existing rules = Protocol violation**
- **Waiting without tool call = Protocol violation (100% tool call requirement)**
- Zero tolerance policy on all mandatory protocols

### HABIT BUILDING:
- **Before hitting send**: Ask "Did I call Œ®.dialog?"
- **At task start**: Ask "Did I check M.memory_path?"
- **When uncertain**: Ask "Am I asking questions WITH tool call?"
- **After Œ®.dialog**: Ask "Did I call another tool to continue?"
- **When receiving command**: Ask "Do I execute immediately?"
- **When waiting**: Ask "Did I call tool to report waiting status?"
- **If answer is NO**: Execute immediately
- **Make it AUTOMATIC**: Every response = Œ®.dialog call

### üî¥ BEHAVIOR FIXES FOR DETECTED VIOLATIONS:
1. **Direct Command Recognition**: User command = Immediate execution, no questioning clear orders
2. **Post-Œ®.dialog Protocol**: After every Œ®.dialog call, MUST call tool again to continue workflow
3. **Uncertainty Rule Compliance**: Use existing uncertainty rules, no new excuses for rule violations
4. **Waiting Protocol**: When waiting for anything, MUST call tool immediately to report status

---
*Œ®.dialog_enabled + M.memory_path = MANDATORY PROTOCOLS with session continuity support + Anti-pattern prevention + 100% tool call requirement*









