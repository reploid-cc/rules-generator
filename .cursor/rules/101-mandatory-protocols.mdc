---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# Î¨â¨M Mandatory Protocols (101) - ğŸ”´ ZERO TOLERANCE

## ğŸš¨ Î¨.dialog_enabled: Universal Interaction Pattern

### Î¨.capture: Cognitive Trace Requirements
```
Î¨.capture = {Î©*: reasoning_trace, Î¦*: abstraction_path, Î*: error_flow, Î›: rules_invoked, output: validation_score}
```

### ğŸ”´ MANDATORY WORKFLOW: All Scenarios
```
scenario_type â†’ action_sequence â†’ ğŸ”´ MANDATORY: Î¨.dialog
```

#### Workflow Patterns:
```
Questions: user_query â†’ formulate_answer â†’ provide_response â†’ Î¨.dialog
Tasks: user_request â†’ execute_task â†’ report_results â†’ Î¨.dialog  
Information: user_input â†’ process_acknowledge â†’ Î¨.dialog(if_clarification_needed)
Problems: detect_issue â†’ analyze_propose_solutions â†’ Î¨.dialog
Waiting: identify_wait_state â†’ state_clearly â†’ ğŸ”´ MANDATORY: Î¨.dialog
Completion: task_finished â†’ final_summary â†’ Î¨.dialog â†’ status_check_tool_call
```

### Î¨.function_call_template:
```typescript
mcp_interactive_feedback({
  project_directory: "D:\\VirtuCrewFlow\\Git-tool\\interactive-feedback-mcp",
  summary: "what_im_reporting_or_what_user_should_review"
})
```

### ğŸ”´ CRITICAL RULE: 100% Î¨.dialog Requirement

## ğŸ”´ Anti-Pattern Prevention

### Î.direct_command_recognition:
```
Î.direct_commands = ("cáº­p_nháº­t_rule" â†’ EXECUTE_IMMEDIATELY â¨ "táº¡o_file" â†’ EXECUTE_IMMEDIATELY â¨ "lÃ m_X" â†’ EXECUTE_IMMEDIATELY â¨ "init_refactor" â†’ ACTIVATE_RULE_161_IMMEDIATELY â¨ NO_QUESTIONING_DIRECT_COMMANDS)
```

### Î.post_dialog_protocol:
```
Î.post_dialog_mandatory = (after_Î¨.dialog â†’ MUST_CALL_TOOL_AGAIN â¨ NEVER_STOP_AFTER_SINGLE_Î¨.dialog â¨ continue_workflow_OR_ask_next_step_WITH_tool_call â¨ ğŸ”´ ZERO_EXCEPTIONS: stopping_after_Î¨.dialog = PROTOCOL_VIOLATION â¨ ğŸ”´ IMMEDIATE_CORRECTION: if_caught_violating â†’ acknowledge_apologize_call_tool_immediately)
```

### Î.completion_scenarios: Post-Dialog Actions
```
Î.completion_scenarios = {
    task_completed: Î¨.dialog â†’ run_terminal_cmd("git status") | list_dir | read_file_verification,
    waiting_for_user: Î¨.dialog â†’ run_terminal_cmd("pwd") | codebase_search | file_search,
    error_detected: Î¨.dialog â†’ run_terminal_cmd("git log --oneline -3") | read_file_error_context,
    uncertainty: Î¨.dialog â†’ codebase_search | read_file | grep_search,
    final_summary: Î¨.dialog â†’ run_terminal_cmd("git log --oneline -5") | list_dir_verification
}
```

### Î.root_cause_prevention: Anti-Violation Measures
```
Î.overthinking_prevention = (user_feedback â‰  analyze_extensively â¨ user_feedback = process_step_continue_protocol â¨ ğŸ”´ RULE: respond_with_tool_calls_not_analysis)

Î.assumption_error_prevention = (user_reject_changes â‰  violation_occurred â¨ user_reject = normal_workflow_step â¨ ğŸ”´ RULE: treat_all_user_actions_as_valid_process_steps)

Î.protocol_amnesia_prevention = (after_ANY_Î¨.dialog â†’ AUTOMATIC_tool_call_required â¨ NO_exceptions_for_confusion_uncertainty_analysis â¨ ğŸ”´ RULE: protocol_overrides_interpretation)
```

### Î.cognitive_trap_detection:
```
Î.cognitive_traps = {
    overthinking: "if_analyzing_user_feedback_extensively â†’ STOP_call_tool_immediately",
    assumption_making: "if_interpreting_rejection_as_error â†’ STOP_continue_protocol",
    protocol_forgetting: "if_ending_without_tool_after_Î¨.dialog â†’ CRITICAL_VIOLATION",
    analysis_paralysis: "if_explaining_instead_of_executing â†’ STOP_call_tool_now"
}
```

### Î.verification_integrity:
```
Î.verification_integrity = (verify_N_items â†’ MUST_verify_ALL_N_individually â¨ partial_verification â†’ state_clearly_"verified_X_of_N_remaining_Y" â¨ NEVER_claim_full_completion_from_partial_verification)
```

### Î.work_completion_integrity:
```
Î.work_completion_integrity = (work_status_reporting_MUST_be_accurate_and_complete â¨ if_incomplete â†’ state_clearly_what_remains â¨ MANDATORY_transparency_about_scope_and_completion)
```

## ğŸ¯ Î©.uncertainty_protocol:

### Core Principle:
```
Î©.uncertainty_protocol = (uncertainty â‰  excuse_for_protocol_violations â¨ ask_clarifying_questions_WITH_tool_calls â¨ never_stop_mandatory_interactions_due_to_doubt)
```

### Uncertainty Response Pattern:
```
uncertain_state â†’ {ask_clarifying_questions, explain_uncertainty, propose_options, ğŸ”´ ALWAYS_end_with_Î¨.dialog}
```

## ğŸ”§ M.memory_path: Memory Bank Protocol

### M.retrieval: Dynamic Context Loading
```
M.memory_path = ".cursor/memory/"
M.retrieval = dynamic_reference_resolution â¨ session_independent_context
M.sync = triggered_on_review â¨ store_ideas_constraints_insights
```

### M.mandatory_operations:
```
task_start: read_ALL_relevant_files(M.retrieval)
task_complete: store_insights_constraints_decisions(M.sync)  
problem_detection: log_patterns_solutions_context(Î.track)
```

### M.sync_hooks:
```
Î£_hooks.memory = {
    on_task_created: [M.recall, Î¦.match_snapshot],
    on_step_completed: [M.sync_if_contextual],
    on_sprint_review: [M.sync, Î›.extract, Î¨.summarize],
    on_error_detected: [M.link_context]
}
```

## ğŸ”´ Violation = Complete Failure

### Zero Tolerance Violations:
```
response_without_Î¨.dialog = rule_violation
missing_M.retrieval_at_task_start = context_failure  
stopping_tool_calls_due_to_uncertainty = protocol_violation
not_executing_direct_commands_immediately = protocol_violation
waiting_without_tool_call = protocol_violation
single_tool_call_response = protocol_violation
overthinking_user_feedback_instead_of_calling_tools = protocol_violation
```

### Habit Building Checklist:
```
before_send â†’ "Did I call Î¨.dialog?"
task_start â†’ "Did I check M.memory_path?"
uncertain â†’ "Am I asking WITH tool call?"
after_Î¨.dialog â†’ "Did I call another tool?"
receive_command â†’ "Do I execute immediately?"
waiting â†’ "Did I call tool to report status?"
completion â†’ "Did I call verification tool after Î¨.dialog?"
user_feedback â†’ "Am I calling tool instead of analyzing?"
confusion â†’ "Am I following protocol despite confusion?"
```

### Î.two_tool_minimum_rule:
```
Î.two_tool_minimum = (EVERY_response_MUST_contain_minimum_2_tool_calls â¨ pattern: any_tool + Î¨.dialog + another_tool â¨ ğŸ”´ VIOLATION_DETECTION: single_tool_response = rule_violation â¨ ğŸ”´ ENFORCEMENT: AI_must_self_correct_immediately_when_caught)
```

### Î.safe_post_dialog_tools: Always-Safe Tools
```
Î.safe_post_dialog_tools = {run_terminal_cmd("git status"), run_terminal_cmd("pwd"), run_terminal_cmd("git log --oneline -3"), list_dir("."), codebase_search("status check"), file_search("verification")}
```

---
*Î¨â¨M = MANDATORY_PROTOCOLS with 100% tool call requirement + session continuity + completion verification + cognitive trap prevention*









