---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# ğ•Œ Universal Notation Definitions (000)

## ğŸ¯ Core System Symbols

### Primary Systems
```
Î©* = max(âˆ‡Î£Î©) âŸ¶ intent_aligned_reasoning
Î¨ = cognitive_trace_dialogue_system
M = file_based_memory_system  
T = structured_task_system
Î› = rule_based_self_learning
Î¦* = hypothesis_abstraction_engine
Î* = diagnostics_refinement_engine
Dâº = contradiction_resolver
```

### Mathematical Operators
```
â¨ = logical_AND_composition
â†’ = implies_triggers_leads_to
â‡Œ = bidirectional_relationship
âŸ¶ = transformation_mapping
âˆ‡ = gradient_optimization
Î£ = summation_integration
âˆˆ = element_of_belongs_to
âŠ† = subset_of_contained_in
âˆª = union_combination
âˆ© = intersection_overlap
```

### Hierarchical Notation
```
Î©.modes = reasoning_framework_modes
Î©_H = hierarchical_problem_decomposition
Î©â‚œ = trust_validation_framework
Î¨.capture = cognitive_trace_requirements
Î¨.dialog = interactive_feedback_system
M.memory_path = file_based_memory_location
T.task_system = structured_task_management
Î›.rules = rule_learning_system
```

## ğŸ¯ Functional Notation Patterns

### System Integration
```
Î£_hooks = {
    on_event: [system_responses],
    trigger_condition: [automated_actions]
}
```

### Conditional Logic
```
if condition â†’ action
when trigger â¨ context â†’ response
unless constraint â†’ alternative_action
```

### Composition Patterns
```
system = (
    component_1
    â¨ component_2  
    â¨ component_3
)
```

## ğŸ¯ Status & State Notation

### Execution States
```
âœ… = completed_successful
â³ = in_progress_waiting
ğŸ”´ = critical_mandatory
ğŸŸ¡ = warning_attention_needed
ğŸŸ¢ = optional_nice_to_have
âŒ = failed_incorrect
```

### Priority Levels
```
MANDATORY = zero_tolerance_required
CRITICAL = immediate_attention_required
HIGH = important_priority
MEDIUM = standard_priority
LOW = optional_when_time_permits
```

## ğŸ¯ Cross-Reference Notation

### Rule References
```
rule_XXX = reference_to_rule_number_XXX
Î›.XXX = lambda_rule_XXX_reference
â†’ rule_XXX = see_rule_XXX_for_details
```

### System Cross-References
```
via_Î© = through_omega_reasoning_system
via_Î¨ = through_psi_dialogue_system
via_M = through_memory_system
via_T = through_task_system
```

## ğŸ¯ Workflow Notation

### Process Flow
```
step_1 â†’ step_2 â†’ step_3
parallel_process_A â¨ parallel_process_B
conditional_branch: if_X â†’ path_A, else â†’ path_B
```

### Validation Patterns
```
validate(condition) â†’ proceed | rollback
test(functionality) â†’ pass â¨ fail
verify(requirement) â†’ satisfied | missing
```

## ğŸ¯ Quality & Metrics

### Measurement Notation
```
baseline_metric = initial_measurement
target_metric = desired_outcome
current_metric = present_state
reduction_percentage = (baseline - current) / baseline * 100
```

### Threshold Notation
```
threshold_value â‰¥ minimum_acceptable
performance_metric â‰¤ maximum_allowed
quality_score âˆˆ [acceptable_range]
```

## ğŸ¯ Error & Exception Handling

### Error States
```
error_detected â†’ stop_immediately
critical_failure â†’ execute_rollback
warning_condition â†’ log_and_continue
```

### Recovery Patterns
```
rollback_to(safe_state)
restore_from(backup_point)
retry_with(modified_parameters)
```

---

*ğ•Œ = Universal_Notation_System for consistent mathematical representation across User Rules framework*


