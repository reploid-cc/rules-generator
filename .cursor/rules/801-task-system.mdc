---
description: 
globs: 
alwaysApply: false
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# T Task System & Sprint Management (801)

## 🎯 T: Structured Task System

### T.path Configuration
```
T = Σ(τ_complex) ⇌ structured task system
T.plan_path = ".cursor/tasks/"
T.backlog_path = ".cursor/tasks/backlog.md"
T.sprint_path = ".cursor/tasks/sprint_{n}/"
T.structure = (step_n.md ⨁ review.md)
```

### T.progress: Task Metadata
```
T.progress = in-file metadata {status: [pending|in_progress|done|blocked], priority: [low|medium|high|critical], notes: contextual_observations, complexity: [simple|medium|complex], estimated_effort: time_estimate}
```

## 🎯 T.backlog: Task Pool Management

### Auto-Prioritization Algorithm
```
T.backlog = task_pool with auto-prioritization
T.priority_score = (business_value * 0.4 ⨁ complexity_inverse * 0.3 ⨁ dependencies_weight * 0.2 ⨁ user_urgency * 0.1)
```

### Task Pool Structure
```
T.backlog_structure = {high_priority: [CRITICAL_immediate_attention, HIGH_important_feature_development], medium_priority: [MEDIUM_enhancement_optimization, MEDIUM_documentation_updates], low_priority: [LOW_nice_to_have_improvements, LOW_technical_debt_cleanup]}
```

## 🎯 T.sprint: Sprint Organization

### Sprint Structure
```
T.sprint_structure = {step_n.md: implementation_steps, spec_step_n.md: TDD_specifications, review.md: sprint_retrospective}
```

### T.update_task_progress Protocol
```
T.update_task_progress = (locate current step in sprint or backlog ⨁ update status = "done" ⨁ check checklist items based on observed completion ⨁ append notes if partial or modified)
```

## 🎯 T.sprint_review: Quality Gates

### Review Triggers
```
T.sprint_review = (trigger on validation ⨁ run M.sync ⨁ Λ.extract ⨁ Φ.snapshot ⨁ Ψ.summarize)
```

### Sprint Completion Criteria
```
T.completion_criteria = {step_files_completed: status_done, TDD_specs_pass: required_coverage, code_review: via_Ξ.cleanup_phase, documentation: updated_in_M.memory_path, reflection: Ψ.sprint_reflection_captured}
```

## 🎯 T Integration with Other Systems

### Σ_hooks: Task Lifecycle Events
```
T.hooks = {
    on_task_created: [M.recall, Φ.match_snapshot],
    on_plan_consolidated: [T.generate_tasks_from_plan, TDD.generate_spec_if_missing, Ψ.materialize_plan_trace, M.sync_if_contextual],
    on_step_completed: [T.update_task_progress, M.sync_if_contextual],
    on_sprint_review: [M.sync, Λ.extract, Ψ.summarize],
    on_sprint_completed: [Ψ.sprint_reflection, Λ.extract, M.sync]
}
```

### Task Materialization
```
Ψ.materialization = (generate .md artifacts automatically when plan granularity reaches execution level ⨁ avoid duplication ⨁ ensure traceability of cognition)
```

## 🎯 Task Quality & Validation

### T.complexity_assessment
```
T.complexity = {simple: single_file_change + minimal_logic, medium: multi_file_changes + moderate_logic + testing_required, complex: architecture_changes + extensive_testing + documentation}
```

### Validation Checkpoints
```
T.validation_gates = (step_completion_verification ⨁ dependency_satisfaction_check ⨁ quality_standards_compliance ⨁ test_coverage_requirements)
```

### Auto-Review Triggers
```
Ψ.enforce_review = (auto-trigger review if step_count > 2 ⨁ or complexity_weight > medium ⨁ or dependencies_detected > 3)
```

---
*T = Σ(τ_complex) ⇌ structured task system with quality gates*


