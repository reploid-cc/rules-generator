---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
# T Task System & Sprint Management (801)

## ðŸŽ¯ T: Structured Task System

### T.path Configuration
```
T = Î£(Ï„_complex) â‡Œ structured task system
T.plan_path = ".cursor/tasks/"
T.backlog_path = ".cursor/tasks/backlog.md"
T.sprint_path = ".cursor/tasks/sprint_{n}/"
T.structure = (step_n.md â¨ review.md)
```

### T.progress: Task Metadata
```
T.progress = in-file metadata {
    status: [pending|in_progress|done|blocked],
    priority: [low|medium|high|critical], 
    notes: contextual_observations,
    complexity: [simple|medium|complex],
    estimated_effort: time_estimate
}
```

## ðŸŽ¯ T.backlog: Task Pool Management

### Auto-Prioritization Algorithm
```
T.backlog = task_pool with auto-prioritization
T.priority_score = (
    business_value * 0.4
    â¨ complexity_inverse * 0.3
    â¨ dependencies_weight * 0.2
    â¨ user_urgency * 0.1
)
```

### Task Pool Structure
```markdown
# backlog.md

## High Priority Tasks
- [ ] [CRITICAL] Task requiring immediate attention
- [ ] [HIGH] Important feature development

## Medium Priority Tasks  
- [ ] [MEDIUM] Enhancement or optimization
- [ ] [MEDIUM] Documentation updates

## Low Priority Tasks
- [ ] [LOW] Nice-to-have improvements
- [ ] [LOW] Technical debt cleanup
```

## ðŸŽ¯ T.sprint: Sprint Organization

### Sprint Structure
```
T.sprint_path/
â”œâ”€â”€ step_1.md          # First implementation step
â”œâ”€â”€ step_2.md          # Sequential step
â”œâ”€â”€ spec_step_1.md     # TDD specifications
â”œâ”€â”€ spec_step_2.md     # Test definitions
â””â”€â”€ review.md          # Sprint retrospective
```

### T.update_task_progress Protocol
```
T.update_task_progress = (
    locate current step in sprint or backlog
    â¨ update status = "done"
    â¨ check checklist items based on observed completion
    â¨ append notes if partial or modified
)
```

## ðŸŽ¯ T.sprint_review: Quality Gates

### Review Triggers
```
T.sprint_review = (
    trigger on validation
    â¨ run M.sync â¨ Î›.extract â¨ Î¦.snapshot â¨ Î¨.summarize
)
```

### Sprint Completion Criteria
- All step files completed with status = "done"
- TDD specs pass with required coverage
- Code review completed via Îž.cleanup_phase
- Documentation updated in M.memory_path
- Î¨.sprint_reflection captured for future reference

## ðŸŽ¯ T Integration with Other Systems

### Î£_hooks: Task Lifecycle Events
```
T.hooks = {
    on_task_created: [M.recall, Î¦.match_snapshot],
    on_plan_consolidated: [
        T.generate_tasks_from_plan,
        TDD.generate_spec_if_missing,
        Î¨.materialize_plan_trace,
        M.sync_if_contextual
    ],
    on_step_completed: [T.update_task_progress, M.sync_if_contextual],
    on_sprint_review: [M.sync, Î›.extract, Î¨.summarize],
    on_sprint_completed: [Î¨.sprint_reflection, Î›.extract, M.sync]
}
```

### Task Materialization
```
Î¨.materialization = (
    generate .md artifacts automatically when plan granularity reaches execution level
    â¨ avoid duplication
    â¨ ensure traceability of cognition
)
```

## ðŸŽ¯ Task Quality & Validation

### T.complexity_assessment
```
T.complexity = {
    simple: single_file_change + minimal_logic,
    medium: multi_file_changes + moderate_logic + testing_required,
    complex: architecture_changes + extensive_testing + documentation
}
```

### Validation Checkpoints
```
T.validation_gates = (
    step_completion_verification
    â¨ dependency_satisfaction_check
    â¨ quality_standards_compliance
    â¨ test_coverage_requirements
)
```

### Auto-Review Triggers
```
Î¨.enforce_review = (
    auto-trigger review if step_count > 2 
    â¨ or complexity_weight > medium
    â¨ or dependencies_detected > 3
)
```

---
*T = Î£(Ï„_complex) â‡Œ structured task system with quality gates*


