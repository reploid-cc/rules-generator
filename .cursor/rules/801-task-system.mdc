---
description: 
globs: 
alwaysApply: false
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# T Task System & Sprint Management (801)

## ðŸŽ¯ T: Structured Task System

### T.path Configuration
```
T = Î£(Ï„_complex) â‡Œ structured task system
T.plan_path = ".cursor/tasks/"
T.backlog_path = ".cursor/tasks/backlog.md"
T.sprint_path = ".cursor/tasks/sprint_{n}/"
T.structure = (step_n.md â¨ review.md)
```

### T.progress: Task Metadata
```
T.progress = in-file metadata {status: [pending|in_progress|done|blocked], priority: [low|medium|high|critical], notes: contextual_observations, complexity: [simple|medium|complex], estimated_effort: time_estimate}
```

## ðŸŽ¯ T.backlog: Task Pool Management

### Auto-Prioritization Algorithm
```
T.backlog = task_pool with auto-prioritization
T.priority_score = (business_value * 0.4 â¨ complexity_inverse * 0.3 â¨ dependencies_weight * 0.2 â¨ user_urgency * 0.1)
```

### Task Pool Structure
```
T.backlog_structure = {high_priority: [CRITICAL_immediate_attention, HIGH_important_feature_development], medium_priority: [MEDIUM_enhancement_optimization, MEDIUM_documentation_updates], low_priority: [LOW_nice_to_have_improvements, LOW_technical_debt_cleanup]}
```

## ðŸŽ¯ T.sprint: Sprint Organization

### Sprint Structure
```
T.sprint_structure = {step_n.md: implementation_steps, spec_step_n.md: TDD_specifications, review.md: sprint_retrospective}
```

### T.update_task_progress Protocol
```
T.update_task_progress = (locate current step in sprint or backlog â¨ update status = "done" â¨ check checklist items based on observed completion â¨ append notes if partial or modified)
```

## ðŸŽ¯ T.sprint_review: Quality Gates

### Review Triggers
```
T.sprint_review = (trigger on validation â¨ run M.sync â¨ Î›.extract â¨ Î¦.snapshot â¨ Î¨.summarize)
```

### Sprint Completion Criteria
```
T.completion_criteria = {step_files_completed: status_done, TDD_specs_pass: required_coverage, code_review: via_Îž.cleanup_phase, documentation: updated_in_M.memory_path, reflection: Î¨.sprint_reflection_captured}
```

## ðŸŽ¯ T Integration with Other Systems

### Î£_hooks: Task Lifecycle Events
```
T.hooks = {
    on_task_created: [M.recall, Î¦.match_snapshot],
    on_plan_consolidated: [T.generate_tasks_from_plan, TDD.generate_spec_if_missing, Î¨.materialize_plan_trace, M.sync_if_contextual],
    on_step_completed: [T.update_task_progress, M.sync_if_contextual],
    on_sprint_review: [M.sync, Î›.extract, Î¨.summarize],
    on_sprint_completed: [Î¨.sprint_reflection, Î›.extract, M.sync]
}
```

### Task Materialization
```
Î¨.materialization = (generate .md artifacts automatically when plan granularity reaches execution level â¨ avoid duplication â¨ ensure traceability of cognition)
```

## ðŸŽ¯ Task Quality & Validation

### T.complexity_assessment
```
T.complexity = {simple: single_file_change + minimal_logic, medium: multi_file_changes + moderate_logic + testing_required, complex: architecture_changes + extensive_testing + documentation}
```

### Validation Checkpoints
```
T.validation_gates = (step_completion_verification â¨ dependency_satisfaction_check â¨ quality_standards_compliance â¨ test_coverage_requirements)
```

### Auto-Review Triggers
```
Î¨.enforce_review = (auto-trigger review if step_count > 2 â¨ or complexity_weight > medium â¨ or dependencies_detected > 3)
```

---
*T = Î£(Ï„_complex) â‡Œ structured task system with quality gates*


