---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->
# Î› Rule-Based Self-Learning System (821)

## ğŸ¯ Î›: Rule-Based Self-Learning

### Î›.path Configuration
```
Î› = rule-based self-learning
Î›.path = ".cursor/rules/"
```

### Î›.naming_convention: Systematic Organization
```
Î›.naming_convention = {
    "0â– â– ": "Core standards",
    "1â– â– ": "Tool configurations", 
    "3â– â– ": "Testing rules",
    "1â– â– â– ": "Language-specific",
    "2â– â– â– ": "Framework-specific", 
    "8â– â– ": "Workflows",
    "9â– â– ": "Templates",
    "_name.mdc": "Private rules"
}
```

**Note**: Category masks, not fixed literals. Use incremental IDs.

## ğŸ¯ Î›.pattern_alignment: Code Quality Enforcement

### Pattern Recognition & Alignment
```
Î›.pattern_alignment = (
    align code with best practices
    â¨ suggest patterns only when justified
    â¨ enforce SRP, avoid premature abstraction
)
```

### Best Practice Enforcement
- **Single Responsibility Principle (SRP)**: One clear purpose per function/class
- **Simplicity Guard**: Challenge overengineering, delay abstraction
- **Pattern Justification**: Only suggest patterns when clearly beneficial
- **Context-Aware**: Apply rules based on project structure and scope

## ğŸ¯ Î›.autonomy: Intelligent Rule Generation

### Auto-Detection System
```
Î›.autonomy = (
    auto-detect rule-worthy recurrences
    â¨ generate _DRAFT.mdc in context
)
```

### Rule Discovery Process
1. **Pattern Detection**: Identify recurring issues or solutions
2. **Context Analysis**: Evaluate if pattern is generalizable
3. **Rule Drafting**: Generate `_DRAFT.mdc` for review
4. **Validation**: Test rule effectiveness across scenarios
5. **Integration**: Promote to official rule with proper naming

## ğŸ¯ Î›.extract: Learning from Experience

### Experience Extraction
```
Î›.extract = (
    triggered on sprint_review
    â¨ analyze what worked vs what didn't
    â¨ identify reusable patterns
    â¨ suggest rule improvements
)
```

### Learning Triggers
- **Recurring Issues**: Same problem appears >2 times
- **Successful Patterns**: Proven effective solutions
- **Anti-Patterns**: Documented problematic approaches
- **Tool Configurations**: Effective setup procedures

### Î.pattern_suggestion Integration
```
Î.recurrence_threshold = 2
Î.pattern_suggestion = (
    if recurring fixable issues detected
    â¨ auto-generate rule draft in Î›.path
    â¨ suggest reusable strategy
)
```

## ğŸ¯ Î› Rule Quality Standards

### Rule Effectiveness Criteria
- **Actionable**: Clear, executable instructions
- **Contextual**: Applies to appropriate scenarios
- **Testable**: Can verify rule effectiveness
- **Maintainable**: Easy to update as context evolves

### Rule Structure Template
```markdown
---
description: Brief rule purpose
globs: [optional file patterns]
alwaysApply: [true|false]
---
# Rule Title (XXX)

## ğŸ¯ Purpose & Context
Clear explanation of when and why this rule applies

## ğŸ¯ Implementation Guidelines
Specific, actionable instructions

## ğŸ¯ Quality Validation
How to verify rule effectiveness

## ğŸ¯ Integration Points
How this rule interacts with other systems

---
*Rule effectiveness tracking note*
```

## ğŸ¯ Î› Integration with Other Systems

### Rule Activation Context
```
Î©.scope = (
    infer project structure from files + imports
    â¨ detect implicit dependencies
    â¨ observe ripple effects
    â¨ activate Î›.rules in-context
    â¨ silent_observer_mode to respect IDE logic
)
```

### Cross-System Integration
- **Î¨ Traces**: Rules invoked logged in cognitive traces
- **T Tasks**: Rule compliance checked in task validation
- **Î Diagnostics**: Rule effectiveness monitored
- **M Memory**: Rule patterns stored for future reference

### Rule Conflict Resolution
```
Dâº.rule_conflict = (
    identify conflicting rules
    â¨ resolve by priority, context, or specificity
    â¨ log resolution in Î¨.dialog
)
```

---
*Î› = rule-based self-learning with intelligent pattern detection*


