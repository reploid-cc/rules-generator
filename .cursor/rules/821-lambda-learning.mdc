---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# Λ Rule-Based Self-Learning System (821)

## 🎯 Λ: Rule-Based Self-Learning

### Λ.path Configuration
```
Λ = rule-based self-learning
Λ.path = ".cursor/rules/"
```

### Λ.naming_convention: Systematic Organization
```
Λ.naming_convention = {
    "0■■": "Core standards",
    "1■■": "Tool configurations", 
    "3■■": "Testing rules",
    "1■■■": "Language-specific",
    "2■■■": "Framework-specific", 
    "8■■": "Workflows",
    "9■■": "Templates",
    "_name.mdc": "Private rules"
}
```

**Note**: Category masks, not fixed literals. Use incremental IDs.

## 🎯 Λ.pattern_alignment: Code Quality Enforcement

### Pattern Recognition & Alignment
```
Λ.pattern_alignment = (align code with best practices ⨁ suggest patterns only when justified ⨁ enforce SRP, avoid premature abstraction)
```

### Best Practice Enforcement
```
Λ.best_practices = {SRP: one_clear_purpose_per_function, simplicity_guard: challenge_overengineering_delay_abstraction, pattern_justification: suggest_only_when_beneficial, context_aware: apply_based_on_project_structure}
```

## 🎯 Λ.autonomy: Intelligent Rule Generation

### Auto-Detection System
```
Λ.autonomy = (auto-detect rule-worthy recurrences ⨁ generate _DRAFT.mdc in context)
```

### Rule Discovery Process
```
Λ.discovery_process = (pattern_detection → context_analysis → rule_drafting → validation → integration)
```

## 🎯 Λ.extract: Learning from Experience

### Experience Extraction
```
Λ.extract = (triggered on sprint_review ⨁ analyze what worked vs what didn't ⨁ identify reusable patterns ⨁ suggest rule improvements)
```

### Learning Triggers
```
Λ.learning_triggers = {recurring_issues: >2_occurrences, successful_patterns: proven_effective_solutions, anti_patterns: documented_problematic_approaches, tool_configurations: effective_setup_procedures}
```

### Ξ.pattern_suggestion Integration
```
Ξ.recurrence_threshold = 2
Ξ.pattern_suggestion = (if recurring fixable issues detected ⨁ auto-generate rule draft in Λ.path ⨁ suggest reusable strategy)
```

## 🎯 Λ Rule Quality Standards

### Rule Effectiveness Criteria
```
Λ.effectiveness_criteria = {actionable: clear_executable_instructions, contextual: applies_to_appropriate_scenarios, testable: can_verify_effectiveness, maintainable: easy_to_update_as_context_evolves}
```

### Rule Structure Template
```
Λ.rule_template = {metadata: description_globs_alwaysApply, title: Rule_Title_XXX, purpose_context: when_and_why_applies, implementation: specific_actionable_instructions, validation: verify_effectiveness, integration: interaction_with_other_systems, tracking: effectiveness_note}
```

## 🎯 Λ Integration with Other Systems

### Rule Activation Context
```
Ω.scope = (infer project structure from files + imports ⨁ detect implicit dependencies ⨁ observe ripple effects ⨁ activate Λ.rules in-context ⨁ silent_observer_mode to respect IDE logic)
```

### Cross-System Integration
```
Λ.integration = {Ψ_traces: rules_invoked_logged_in_cognitive_traces, T_tasks: rule_compliance_checked_in_task_validation, Ξ_diagnostics: rule_effectiveness_monitored, M_memory: rule_patterns_stored_for_future_reference}
```

### Rule Conflict Resolution
```
D⍺.rule_conflict = (identify conflicting rules ⨁ resolve by priority, context, or specificity ⨁ log resolution in Ψ.dialog)
```

---
*Λ = rule-based self-learning with intelligent pattern detection*


