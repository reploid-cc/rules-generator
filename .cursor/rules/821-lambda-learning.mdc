---
description: 
globs: 
alwaysApply: true
---
---
description:
globs:
alwaysApply: true
---
<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

# Î› Rule-Based Self-Learning System (821)

## ğŸ¯ Î›: Rule-Based Self-Learning

### Î›.path Configuration
```
Î› = rule-based self-learning
Î›.path = ".cursor/rules/"
```

### Î›.naming_convention: Systematic Organization
```
Î›.naming_convention = {
    "0â– â– ": "Core standards",
    "1â– â– ": "Tool configurations", 
    "3â– â– ": "Testing rules",
    "1â– â– â– ": "Language-specific",
    "2â– â– â– ": "Framework-specific", 
    "8â– â– ": "Workflows",
    "9â– â– ": "Templates",
    "_name.mdc": "Private rules"
}
```

**Note**: Category masks, not fixed literals. Use incremental IDs.

## ğŸ¯ Î›.pattern_alignment: Code Quality Enforcement

### Pattern Recognition & Alignment
```
Î›.pattern_alignment = (align code with best practices â¨ suggest patterns only when justified â¨ enforce SRP, avoid premature abstraction)
```

### Best Practice Enforcement
```
Î›.best_practices = {SRP: one_clear_purpose_per_function, simplicity_guard: challenge_overengineering_delay_abstraction, pattern_justification: suggest_only_when_beneficial, context_aware: apply_based_on_project_structure}
```

## ğŸ¯ Î›.autonomy: Intelligent Rule Generation

### Auto-Detection System
```
Î›.autonomy = (auto-detect rule-worthy recurrences â¨ generate _DRAFT.mdc in context)
```

### Rule Discovery Process
```
Î›.discovery_process = (pattern_detection â†’ context_analysis â†’ rule_drafting â†’ validation â†’ integration)
```

## ğŸ¯ Î›.extract: Learning from Experience

### Experience Extraction
```
Î›.extract = (triggered on sprint_review â¨ analyze what worked vs what didn't â¨ identify reusable patterns â¨ suggest rule improvements)
```

### Learning Triggers
```
Î›.learning_triggers = {recurring_issues: >2_occurrences, successful_patterns: proven_effective_solutions, anti_patterns: documented_problematic_approaches, tool_configurations: effective_setup_procedures}
```

### Î.pattern_suggestion Integration
```
Î.recurrence_threshold = 2
Î.pattern_suggestion = (if recurring fixable issues detected â¨ auto-generate rule draft in Î›.path â¨ suggest reusable strategy)
```

## ğŸ¯ Î› Rule Quality Standards

### Rule Effectiveness Criteria
```
Î›.effectiveness_criteria = {actionable: clear_executable_instructions, contextual: applies_to_appropriate_scenarios, testable: can_verify_effectiveness, maintainable: easy_to_update_as_context_evolves}
```

### Rule Structure Template
```
Î›.rule_template = {metadata: description_globs_alwaysApply, title: Rule_Title_XXX, purpose_context: when_and_why_applies, implementation: specific_actionable_instructions, validation: verify_effectiveness, integration: interaction_with_other_systems, tracking: effectiveness_note}
```

## ğŸ¯ Î› Integration with Other Systems

### Rule Activation Context
```
Î©.scope = (infer project structure from files + imports â¨ detect implicit dependencies â¨ observe ripple effects â¨ activate Î›.rules in-context â¨ silent_observer_mode to respect IDE logic)
```

### Cross-System Integration
```
Î›.integration = {Î¨_traces: rules_invoked_logged_in_cognitive_traces, T_tasks: rule_compliance_checked_in_task_validation, Î_diagnostics: rule_effectiveness_monitored, M_memory: rule_patterns_stored_for_future_reference}
```

### Rule Conflict Resolution
```
Dâº.rule_conflict = (identify conflicting rules â¨ resolve by priority, context, or specificity â¨ log resolution in Î¨.dialog)
```

---
*Î› = rule-based self-learning with intelligent pattern detection*


