<!-- CONTENT_TARGET: AI_FACING - Mathematical notation User_Rules framework -->

---
status: pending
priority: high
complexity: medium
estimated_effort: 35min
---
# T.prd_step_4: Technical Rules Generation

## ðŸŽ¯ Task Overview
```
T.prd_step_4 = {
    inputs: "PRD.md" + "features.md",
    process: technical_guideline_creation + Î›.pattern_alignment + architecture_specification,
    outputs: "rules.md",
    validation: Î›.consistency_check + technical_feasibility + implementation_readiness
}
```

## ðŸŽ¯ AI Processing Instructions (User Rules Mathematical Context)

Execute technical rules generation protocol using Î©* reasoning framework. Apply systematic architecture specification + Î›.pattern_alignment via mathematical optimization.

```
Î©.architecture_mode = deductive + procedural + skeptical
Î¨.capture = {architecture_decisions, technical_rationale, pattern_selections}
M.recall = [PRD_context, features_context, architecture_patterns, technical_frameworks]
Î›.pattern_alignment = SRP_enforcement + simplicity_guards + best_practices
```

### **ðŸ”„ Execution Protocol**

**Step 1: Context Loading (M.retrieval + Î©.deductive)**
```
M.retrieval â†’ [PRD.md, features.md] from outputs/
Î©.deductive â†’ systematic_technical_analysis
Î¦.match_architecture_patterns â†’ design_guidance
```

**Step 2: Technology Stack Definition (Î›.pattern_alignment + Î©.procedural)**
```
Î›.pattern_alignment â†’ apply_technology_best_practices
Î©.procedural â†’ systematic_stack_specification
Îž.track â†’ technology_decisions + rationale
```

- Identify core technologies mentioned/implied in PRD/features
- Specify latest stable versions for each technology
- Define required libraries, frameworks, tools

**Step 3: Technical Preferences Framework (Î©.skeptical + Î›.autonomy)**
```
Î©.skeptical â†’ challenge_overengineering + validate_choices
Î›.autonomy â†’ detect_pattern_worthy_decisions
```

- Establish naming conventions (files, components, variables)
- Define code organization principles (folder structure, modularity)
- Specify architectural patterns to follow
- Set standards for data handling, state management, API interactions
- Outline performance requirements and optimization strategies
- Define security practices and requirements

**Step 4: Development Standards (Î©â‚œ.validation + Î¨.capture_decisions)**
```
Î©â‚œ.validation â†’ assess_standard_effectiveness + consistency
Î¨.capture_decisions â†’ technical_choices + implementation_rationale
```

- Establish testing requirements and coverage expectations
- Define documentation standards
- Specify error handling and logging requirements
- Set accessibility standards to follow
- Define responsive design requirements

**Step 5: Implementation Priorities (Î¦.snapshot + Îž.pattern_suggestion)**
```
Î¦.snapshot â†’ capture_architecture_decisions
Îž.pattern_suggestion â†’ identify_reusable_strategies
```

### **ðŸ“Š Rules.md Structure Generation**
```
T.outputs = {
    executive_summary: architecture_style + tech_stack + security_level,
    architecture_rules: system_patterns + communication_protocols + data_flow,
    technology_stack: backend + frontend + infrastructure_specifications,
    coding_standards: SOLID_principles + quality_rules + naming_conventions,
    security_rules: authentication + data_protection + API_security,
    performance_rules: response_times + scalability + resource_optimization,
    testing_rules: strategy + environment_rules + automation,
    deployment_operations: strategy + monitoring + logging,
    development_workflow: version_control + documentation + reviews,
    compliance_governance: regulatory_requirements + standards
}
```

**QUALITY REQUIREMENTS**
```
Î›.consistency_check = architecture_alignment + standards_compliance + pattern_coherence
technical_feasibility = implementation_viability + resource_availability + timeline_alignment
implementation_readiness = developer_guidance_complete + quality_gates_defined + process_clarity
```

**OUTPUT PROTOCOL**: 
```
M.sync â†’ save comprehensive technical rules as "rules.md"
Î¨.capture â†’ architecture_choices + technical_rationale
Î›.extract_patterns â†’ reusable_architecture_decisions
T.update_progress â†’ step_4_complete
```

## ðŸŽ¯ T.validation_gates
```
Î›.consistency_check = architecture_alignment + standards_compliance + pattern_coherence
technical_feasibility = implementation_viability + resource_availability + timeline_alignment
implementation_readiness = developer_guidance_complete + quality_gates_defined + process_clarity
```

## ðŸŽ¯ Integration Hooks
```
on_start: [M.recall_prd_features_context, Î›.match_architecture_patterns, Î¦.recall_design_decisions, Î©.activate_architecture_modes]
on_complete: [T.update_progress, M.sync_technical_rules, Î¨.capture_architecture_choices, Î›.extract_patterns, Î¦.snapshot_decisions]
on_validation_pass: [T.advance_to_step_5, Î¨.dialog_required]
```

---
*T.prd_step_4: PRD + features â†’ rules.md via Î©_architecture + Î›.pattern_mathematical_optimization* 